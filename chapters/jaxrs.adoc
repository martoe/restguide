= JAX-RS

Java API for RESTful Web Services (_JAX-RS_) is the specification that provides support in creating web services according to the REST architectural pattern.

RESTful Web Services are configured by using annotations.
These annotations can be used in _POJOs_ but also in _EJBs_.
In next examples and for maintaining us container agnostic, we are only going to use _JAX-RS_ specification classes which means they will be portable across containers and _JAX_RS_ implementations.
Also to be focused on REST, we are not going to use _EJBs_ but pure _POJOs_.

.About Apache TomEE
****
*Apache TomEE* is a _Java EE_ certified web profile application server.
We can summarize as *Apache TomEE = Apache Tomcat + Java EE*.

_RESTful Web Services_ can be done in Java by using any of _JAX-RS_ implementation like _Jersey_, _Apache CXF_ or _REASTEasy_.
Any of this technologies requires a servlet container to run.
All of them can be integrated inside any servlet container like _Tomcat_, _Jetty_, ... but in these examples we are going to use *Apache TomEE* which it comes with _JAX-RS_ provider integrated.
****

== @Path

+@Path+ is used to define the endpoint _URL_ of RESTful web service.
It can be templatized to pass path parameters from _URL_ path.
Query parameters are not set as _URL_ parameters and in case we need to get query parameters, different annotation must be used.

Let's see first example of simple RESTful Web Service which gets all books using `GET` _HTTP_ method.

[source, java]
.BookResource.java
----
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/books") // <1>
public class BookResource {

  @GET // <2>
  @Produces(MediaType.APPLICATION_JSON) // <3>
  public Response books() {
    List<Book> books = Arrays.asList(new Book("Book1"), new Book("Book2"));
    String json = toJson(books); // <4>
    return Response.ok(json).build(); // <5>
  }

}
----
<1> `@Path` sets a class as REST endpoint. In this case is bound to `/books`.
<2> `@GET` sets which _HTTP_ method is required for executing this method.
<3> Because of content negotiation, the media type must be set. In this case because method does not receive anything, we only need to configure the return type with `@Produces` annotation.
<4> _Java EE_ specification does not provide any specific way to convert from/to object to _JSON_. There is no _JSON-B_ spec. Most providers implements their own system for converting _POJOs_ into required internet type, but you can also converting entities by your own code.
<5> Finally instead of returning a list of books alone, a list of books among with an _HTTP_ 200 code is returned.

Then we can access this resource in `http://<host>:<port>/<application>/books`.

[[JSON-B]]
[TIP]
====
*JAVA EE 8* will face the problem of standarizing the _JSON Binding_ problem. Since that point you can use the method provided by _JAX-RS_ provider, or you can implement your own.

What _JAX-RS_ specification provides is an standard way to deal with binding by providing a standard interface to be implemented for converting '`string`' content into object and viceversa.
It is important to know exactly which library uses _JAX-RS_ for binding _JSON_.
If this library fits your requirements, then go ahead with it but keep in mind that you are loosing portability across vendors.
If you want to use another library or you need to maintain portability then use the standard annotations to implement your own method.
====

One way to pass parameters to REST endpoints is by specifying _URI_ path parameter.
In previous example there was no parameters so all books were returned.
In next example we are going to pass book id of required book, so instead or returning a list of books, a single book is returned.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @GET
  @Path("{bookId}") // <1> <2>
  @Produces(MediaType.APPLICATION_JSON)
  public Response book(@PathParam("bookId") String bookId) { // <3>

    Book book = findBookById(bookId); // <4>

    if(book != null) {
      return Response.ok(book).build();
    } else {
      return Response.status(Status.NOT_FOUND).build(); // <5>
    }

  }
}
----
<1> `@Path` annotation can be used in a method as well. It simply adds a new path to the path defined at class level.
<2> _URI_ path templates are variables denoted by curly braces. At runtime this template is substituted by real value.
<3> To get path template in method `@PathParam` annotation is used passing the template name.
<4> Value is set to variable and can be used directly without any transformation.
<5> In case of _book_ not found an _HTTP_ 404 code response is sent back. More information about exception handling in next sections.

We can access this resource in `http://<host>:<port>/<application>/books/123`.

[TIP]
====
Caller can add any _URL_ valid character as path parameter.
In most cases the path parameter will be an integer or a it will contain a well-known pattern.
To protect your endpoints you can set a regular expression on path template.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @GET
  @Path("{bookId: [0-9]+}") // <1>
  @Produces(MediaType.APPLICATION_JSON)
  public Response book(@PathParam("bookId") String bookId) {

    Book book = findBookById(bookId);

    if(book != null) {
      return Response.ok(book).build();
    } else {
      return Response.status(Status.NOT_FOUND).build();
    }

  }
}
----
<1> The way to add a regular expression is by adding the name of the path param and the regular expression separated by colon '`:`'.


Resource in `http://<host>:<port>/<application>/books/123` will work but `http://<host>:<port>/<application>/books/abc` returns an _HTTP_ 404 code error.
====

== Extracting request parameters

In <<@Path>> we have seen that we can pass path parameters and extract them using `@PathParam`.
But there are other ways to send parameters in RESTful Web Services:

@PathParam:: Extracts parameters from _URL_ path.
@QueryParam:: Extracts parameters from query path.
@FormParam:: Extracts parameters from a request of _MIME_ media type `application/x-www-form-urlencoded`.
@MatrixParam:: Extracts parameters from an _HTTP_ matrix parameters. Matrix parameters are a set of `name=value` in _URL_ path separated by semicolon '`;`'.
@HeaderParam:: Extracts parameters from _HTTP_ header.
@CookieParam:: Exrtacts parameters from a _cookie_.

TIP: Avoid using `@FormParam` because you are tighten endpoint with presentation layer. Also prefer using `@QueryParam` in front of `@MatrixParam`.

[NOTE]
====
All previous ways of extracting parameters from a request (`@PathParam`, `@FormParam`, `@QueryParam` ...) can be preceded by `@DefaultValue` annotation.
This annotation sets the default value in case a parameter is not provided.

[source, java]
.BookResource
----
@GET
public String books(@DefaultValue("100") @QueryParam("price")int maxResults) {
  return ...;
}
----
====

=== @QueryParam

`@QueryParam` extracts parameters from query path.
Query is an optional part separated from path with a question mark '`?`' and contains pairs of key/value separated by ampersand `'&'`.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  public Response books(@QueryParam("orderBy")String field) { // <1> <2>
    List<Book> books = findAllBooksOrderedBy(field);
    return Response.ok(books).build();
  }
}
----
<1> `@QueryParam` is used in the same way as `@PathParam`.
<2> In case of no query param provided, the endpoint is called as well but a *null* value is set in parameter.

We can access this resource in `http://<host>:<port>/<application>/books?orderBy=name`.

=== @HeaderParam

`@HeaderParam` extracts parameters from _HTTP_ header.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  public Response books(@HeaderParam("user-agent")String userAgent) {
    //..
  }
}
----

=== @CookieParam

`@CookieParam` exrtacts parameters from a _cookie_.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  public Response books(@CookieParam("Last-Accessed")String lastAccessed) {
    //..
  }
}
----

== HTTP methods

In all previous examples _GET_ method has been used as a preferred _HTTP_ method.
But you can use any other _HTTP_ method like _POST_ for creating resources, _PUT_ for updating resources or _DELETE_ for deleteing resources.

=== Creating a resource

To create a resource we must use the _POST_ _HTTP_ method with `@POST` annotation.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @POST // <1>
  @Consumes(MediaType.APPLICATION_JSON) // <2>
  public Response createBook(String jsonBook) { // <3>
    Book book = fromJson(jsonBook); // <4>
    book = insertBook(book);

    return Response.created(URI.create("/"+book.getId())).build(); // <5>
  }
}
----
<1> This method is executed when request is of type _POST_.
<2> This method consumes content instead of producing it. For this reason we must set which media type is consumed by the service.
<3> _JSON_ payload is set as '`string`'.
<4> As mentioned in <<JSON-B, JSON section>> there is no specification about how to bind an object from/to _JSON_. You can implement your own provider or you can leave this responsability to _JAX-RS_ default provider.
<5> Creation implies to assign an id to a resource. This id must be returned as _HTTP_ header parameter named `Location` and _HTTP_ 201 status code.

=== Updating a resource

To update a resource we must use the _PUT_ _HTTP_ method with `@PUT` annotation.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @PUT // <1>
  @Path("{bookId: [0-9]+}")
  @Consumes(MediaType.APPLICATION_JSON)
  public Response updateBook(@PathParam("bookId") String bookId, String jsonBook) {
    Book book = fromJson(jsonBook);
    book = updateBook(book);

    return Response.noContent().build(); // <2>
  }
}
----
<1> This method is executed when request is of type _PUT_.
<2> When an update is produced a no content _HTTP_ code should be returned.

=== Deleting a resource

To delete a resource we must use the _DELETE_ _HTTP_ method with `@DELETE` annotation.

[source, java]
.BookResource
----
@Path("/books")
public class BookResource {

  @DELETE // <1>
  @Path("{bookId: [0-9]+}")
  @Consumes(MediaType.APPLICATION_JSON)
  public Response deleteBook(@PathParam("bookId") String bookId) {
    //delete

    return Response.noContent().build(); // <2>
  }
}
----
<1> This method is executed when request is of type _DELETE_.
<2> When an update is produced a no content _HTTP_ code should be returned.

== Content Negotiation

RESTful Web Services can consume and produce different media type like _JSON_, _XML_ or any other valid type like plain text or binary.

_JAX-RS_ provides `@Consumes` and `@Produces` annotations to set which media type are consumed by the service or produced to the client.
In all previous examples _application/json_ media type has been used, but different kind of type can be used as well.
Next list provides a quick overview of the Java types that are supported with respect to media type.

* All media types (\*/*)
** byte[]
** java.lang.String
** java.io.Reader (inbound)
** java.io.File
** javax.activation.DataSource
** javax.ws.rs.core.StreamingOutput (outbound)
* XML media types (text/xml, application/xml and application/...+xml)
** javax.xml.transform.Source
** javax.xml.bind.JAXBElement
** Application supplied JAXB classes (types annotated with @XmlRootElement or@XmlType)
* JSON media types (text/json, application/json) footnote:[You need to provide the binding library or rely on the one provided by _JAX-RS_ provider.]
** javax.xml.transform.Source
** javax.xml.bind.JAXBElement
** Application supplied JAXB classes (types annotated with @XmlRootElement or@XmlType)
* Form content (application/x-www-form-urlencoded)
** MultivaluedMap<String,String>
* Plain text (text/plain)
** java.lang.Boolean
** java.lang.Character
** java.lang.Number

== Errors

RESTful Web Services can fail because of different situations.
Some of them can be business errors thrown by our process, and others can be errors generated by a third-party library or because of structure problems.

=== Response

Exceptions in _JAX-RS_ are propagated through _HTTP_ response codes as explained in <<Response Codes>> section.
_JAX-RS_ defines `javax.ws.rs.core.Response` class to create response code and sent back to the client.

[[response-example]]
[source, java]
.BookResource.java
----
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response book(@PathParam("bookId") String bookId) {

  Book book = findBookById(bookId);

  if (book != null) {
    return Response.ok(book).build();
  } else {
    return Response.status(Status.NOT_FOUND).build(); // <1>
  }
}
----
<1> Because element is not found an _HTTP_ 404 error code is thrown to the client.

That's right for almost all cases, but what's happening if `findBookById` instead of returning a null value, it would return an un/checked exception?

=== Exceptions

Probably the first thing we could do is wrapping code between a `try/catch` instruction and in catch section add the `Response` call.

But _JAX-RS_ defines `javax.ws.rs.ext.ExceptionMapper` to map any exception (checked or not) to an _HTTP_ response code.
So if the exception is thrown, transparently to the developer, this exception is transformed to _HTTP_ response code and sent back to client.
This class is automatically discovered byt the _JAX-RS_ runtime during provider scanning phase.

[source, java]
.PersistenceExceptionMapper.java
----
import javax.ws.rs.ext.Provider;
import javax.persistence.PersistenceException;

@Provider // <1>
public class PersistenceExceptionMapper implements ExceptionMapper<PersistenceException> {

  @Override
  public Response toResponse(PersistenceException exception) { // <2>
    return Response.status(Status.INTERNAL_SERVER_ERROR)
          .entity(createErrorMessage(exception.getMessage())).type("application/json").build(); // <3>
  }
}
----
<1> Mapper should be annotated with +@Provider+ annotation.
<2> +toResponse+ method builds the response to be sent back to caller.
<3> Along with _HTTP_ code, a message about the error is also returned following <<Error Codes, error nomenclature>>.

== Custom Entity Providers

As we have seen in all previous examples, _JAX-RS_ does not define a way on how to bind an object to its _JSON_ representation and viceversa.
As mentioned this binding can be done by using the one provided by _JAX-RS_ implementation.
For example _Apache CXF_ provides _Jettison_.
If we choose this approach the application would become not portable across providers, but also we could feel more comfortable with other binder like _Gson_ or _Jackson_.

To make binders portable, _JAX-RS_ defines `javax.ws.rs.ext.MessageBodyWrite` interface to map an object to _JSON_ and `javax.ws.rs.ext.MessageBodyReader` to map a _JSON_ document to object.

Let's see an example of binder which uses _Gson_ as mapper.

.About Gson
****
_Gson_ is a java library that can be used to convert java objects into their _JSON_ representation.
It can also be used to convert a _JSON_ string to an equivalent java object.
_Gson_ can work with arbitrary java objects including pre-existing objects that you do not have source-code of.
****

[source, java]
.GsonMessageBodyWriter.java
----
@Provider // <1>
@Produces("application/json") // <2>
public class GsonMessageBodyWriter implements MessageBodyWriter<Object> {

  private Gson gson = new Gson();

  @Override
  public long getSize(Object object, Class<?> clazz, Type type, Annotation[] annotations,
      MediaType mediaType) {
    return -1; // <3>
  }

  @Override
  public boolean isWriteable(Class<?> clazz, Type type, Annotation[] annotations,
      MediaType mediaType) {
    return true; // <4>
  }

  @Override
  public void writeTo(Object object, Class<?> clazz, Type type, Annotation[] annotations,
      MediaType mediaType, MultivaluedMap<String, Object> multivaluedMap,
      OutputStream outputStream) throws IOException {
    String json = gson.toJson(object);
    outputStream.write(json.getBytes()); // <5>
  }
}
----
<1> Marks an implementation of an extension interface that should be discoverable by _JAX-RS_ runtime during a provider scanning phase.
<2> +@Produces+ sets which media type should enable this writer.
<3> If size of return message cannot be calculated a -1 should be returned.
<4> Sets which kind of objects can be converted using this writer. In this case all of them.
<5> _gson_ serializes object.

And inverse operation:

[source, java]
.GsonMessageBodyReader.java
----
@Provider
@Consumes("application/json") // <1>
public class GsonMessageBodyReader implements MessageBodyReader<Object> {

  private Gson gson = new Gson();

  @Override
  public boolean isReadable(Class<?> clazz, Type type, Annotation[] annotations,
      MediaType mediaType) {
    return true;
  }

  @Override
  public Object readFrom(Class<Object> clazz, Type type, Annotation[] arguments,
      MediaType mediaType, MultivaluedMap<String, String> multivaluedMap,
      InputStream inputStream) throws IOException {
    return gson.fromJson(new InputStreamReader(inputStream), type); // <2>
  }
}
----
<1> +@Consumes+ is used instead of +@Produces+.
<2> Input stream is converted to required object.

These class is automatically discovered byt the _JAX-RS_ runtime during provider scanning phase because both of them are annotated with `@Provider`.

NOTE: A single object implementing both interfaces are the common pattern followed in this cases.

[IMPORTANT]
====
_Jackson_ mapper has one artifact which implements a _JAX-RS_ provider.
So if you want to use _Jackson_ as mapper you don't need to implement it by yourself but just adding a new dependency in your `pom.xml` file or copying manually the required artifacts into `WEB-INF/lib`.

[source, xml]
.pom.xml
----
<dependency>
  <groupId>com.fasterxml.jackson.jaxrs</groupId>
  <artifactId>jackson-jaxrs-json-provider</artifactId>
  <version>2.4.3</version>
</dependency>
----
====

== Packaging and Deployment

_JAX-RS_ applications can be packaged and deployed using different three different approaches:

`Application` subclass:: Use a class that extends `javax.ws.rs.core.Application` to define the components of a Restful Web Services and provide additional metadata.
`Servlet`:: Update the `web.xml` deployment descriptor to configure a servlet as dispatcher for RESTful Web Services.
Default:: If you don't configure anything, RESTful Web Services are deployed as defined in classes. An scanning classpath fiding resources are done.

NOTE: In all our previous examples *Default* method has been used.

=== Application

Use a class that extends `javax.ws.rs.core.Application` to define the components of a Restful Web Services and provide additional metadata.
Metadata may include a common base _URI_ for endopints or for example defining which endpoints should be mapped within specified prefix.

In next example `BookResource` endpoint is going to be registered using `javax.ws.rs.core.Application`.

[source, java]
.BookResource.java
----
@Path("/books")
public class BookResource {
    //....
}
----

[source, java]
.BookApplication.java
----
import javax.ws.rs.core.Application;
import javax.ws.rs.ApplicationPath;

@ApplicationPath("public") // <1>
public class BookApplication extends Application {

  public Set<Class<?>> getClasses() {
    Set<Class<?>> s = new HashSet<Class<?>>();
    s.add(BookApplication.class); // <2>
    return s;
  }
}
----
<1> `@ApplicationPath` adds a base _URI_ to all components registered inside this application. In this case _public_.
<2> `BookResource` class is registered within current application.

Now instead of accessing the resource through `http://<host>:<port>/<application>/books`, we need to go to `http://<host>:<port>/<application>/public/books`.

For simple deployments, no `web.xml` deployment descriptor is required.
For more complex deployments, for example to secure the Web service or specify initialization parameters, you can package a `web.xml` deployment descriptor with your application.

=== Servlet

By default `javax.ws.rs.core.Application` classes are self-discovered during classpath scanning phase.
But in case you need to add custom parameters from `web.xml` to `javax.ws.rs.core.Application`, the class must be registered within the file.

[source, xml]
.web.xml
----
<web-app>
  <servlet>
    <display-name>BookApplication Servlet</display-name>
    <servlet-name>BookApplication</servlet-name>
    <init-param>
      <param-name>javax.ws.rs.Application</param-name>
      <param-value>myPackage.BookApplication</param-value>
    </init-param>
  </servlet>
  <servlet-mapping>
    <servlet-name>BookApplication</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
</web-app>
----

=== Default

By default all resources annotated with `@Path` or extending `javax.ws.rs.Application` are auto-discovered when they are at classpath.
This is the default behaviour and the most used.

[TIP]
====
If application that is being developed contains a single (or two) resources it is not necessary to register them as `javax.ws.rs.Application`, but on other cases, the best approach is defining them inside it so you can have an overall picture of all REST endpoints.
Most of the times you don't need to do anything with `web.xml` so rely on scanning process.

One important point is to put `javax.ws.rs.Application` in standard place so anyone can take a quick overview of which resources compose our application and their implementatin.
For this reason a common place to put `javax.ws.rs.Application` class is in `rs` package.
So a valid package is `com.superbiz.app.rs`.


icon:folder-open-o[] Credential Manager +
{nbsp}{nbsp}{nbsp}{nbsp}icon:th-large[] com.superbiz.app.rs +
{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}icon:file-o[] CredentialManagerResources.java +
{nbsp}{nbsp}{nbsp}{nbsp}icon:th-large[] com.superbiz.app.credential.boundary +
{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}icon:file-o[] CredentialResource.java +
{nbsp}{nbsp}{nbsp}{nbsp}icon:th-large[] com.superbiz.app.credential.entity +
{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}icon:file-o[] Credential.java +
====

== Testing

Testing _RESTful Web Services_ can be a bit complicated because there are some logic that are executed by a container.
As we have seen in previous examples you can annotate a class with `@Path` and this class will become a _REST_ endpoint.
Container is in charge of configuring, registering, and running the endpoint and this is not managed by the developer.

The same happens for serializing a returned entity like in <<response-example, this example>>.
The serialization of an entity is done internally by the container.

So running your integration tests requires that you deploy the business code inside the container.
If not you are writing a test that is not exactly running in the same environment as in production and probably you will end up by mocking a lot of container features.

And this is exactly what *Arquillian* fixes.

.Arquillian
****
*Arquillian* is a testing framework that fills the gap between unit tests and integration tests so writting integration tests are as simple as writing a unit tests but running them within/against an application server.

It deals with all the plumbing of container management, deployment, and framework initialization so you can focus on the task of writing your tests—real tests.
*Arquillian* minimizes the burden on you by covering aspects surrounding test execution; some of these aspects are as follows:

* Managing the life cycle of the container (start/stop)
* Bundling the test class with the dependent classes and resources into a deployable archive
* Enhancing the test class (for example, resolving @Inject, @EJB, and @Resource injections)
* Deploying the archive to test applications (deploy/undeploy), and capturing results and failures

You can read more about _Arquillian_ in <<ArquillianHome>>.
****

So let's start by adding _Arquillian_ dependencies.

=== Arquillian dependencies and configuration

[[arquillian-pom]]
[source, xml]
.pom.xml
----
<dependencyManagement>
  <dependencies>
    <dependency>
    <groupId>org.jboss.arquillian</groupId> <!--1-->
    <artifactId>arquillian-bom</artifactId>
    <version>1.1.7.Final</version>
    <scope>import</scope>
    <type>pom</type>
    </dependency>
  </dependencies>
</dependencyManagement>

<dependencies>
  <dependency>
    <groupId>org.apache.openejb</groupId> <!--2-->
    <artifactId>arquillian-tomee-embedded</artifactId>
    <version>1.7.1</version>
    <scope>test</scope>
  </dependency>
  <dependency>
    <groupId>org.apache.openejb</groupId> <!--3-->
    <artifactId>tomee-jaxrs</artifactId>
    <version>1.7.1</version>
    <scope>test</scope>
  </dependency>
</dependencies>

----
<1> Adds _Arquillian_ `bom` file. This makes that all component added as dependency will contain exactly the same version.
<2> Because we are using _Apache TomEE_, this dependency adds _Apache TomEE_ as container to be managed by _Arquillian_.
<3> Embedded _Apache TomEE_ doesn't comes with _JAX-RS_ libraries so we need to add them manually.

Let's see how an Arquillian test looks like:

=== Arquillian Test

[source, java]
----
@RunWith(Arquillian.class) //<1>
public class MoviesServiceTest {

  @Deployment //<2>
  public static JavaArchive createDeploymentPackage() {
    return createDeploymentFile();
  }

  @EJB //<3>
  MoviesService moviesService;

  @Test
  public void shouldCreateMovies() {
    //<4>
  }
}
----
<1> Test must use `Arquillian` runner.
<2> _Arquillian_ needs to know what to deploy on the started container. Deployment file is created in an `static` method annotated with `Deployment`.
<3> By default _Arquillian_ runs tests inside the container so we can use any _Java EE_ annotation available inside the container. In this case `javax.ejb.EJB`.
<4> The test itself using the _EJB_ or whatever we want.

As you may see test looks pretty similar to a unit test, a lot of details about application server or some aspects on how is started and stopped the application server are hidden to the developers.
So what is happening under the covers when previous test is executed?

[ditaa]
.Arquillian Lifecycle
....
+-------------+                           /-------------\
|   Client    |                           |    TomEE    |
+-------------+                           \-------------/
      :                                          :
      |         +----------------------+         |
      |---------| Start Embedded TomEE |-------->|
      |         +----------------------+         |
      |                                          |
      |         +-----------------+              |
      |-------->| Call @Deployment|              |
      |         +-----------------+              |
      |                 |                        |
      |<----------------+                        |
      |                                          |
      |       +-----------------------+          |
      |-------| Deploy Archive + Test |--------->|
      |       +-----------------------+          |
      |                                          |
      |                               +-----------------------+
      |<------------------------------|    Run and Collect    |
      |                               +-----------------------+
      |                                          |
      |       +-----------------------+          |
      |-------|   UnDeploy Archives   |--------->|
      |       +-----------------------+          |
      |                                          |
      |       +-----------------------+          |
      |------ | Stop Embedded TomEE   |--------->|
      |       +-----------------------+          |
      |                                          |
....

First of all _Arquillian_ starts an embedded _Apache TomEE_ (we have defined this in <<arquillian-pom, pom.xml>> in section 2).
Then a method annotated with `Deployment` annotation is called and returns a `JavaArchive` to be deployed.

After that the generated deployment file and the test itself is packaged and deployed to _Apache TomEE_.
The test is run inside the container and the results are sent back to IDE.
Note that this step is required because tests are run inside the container, and the result should be notified to the caller (surefire plugin, IDE, ...).

And finally if there is no more tests to execute container is cleaned from deployed artifacts and _Apache TomEE_ is stopped.

And how should looks like a `@Deployment` annotated method?
To create a deployment file you need to use a project called `Shrinkwrap`.
_Arquillian_ has already this project as dependency so you don't need to worry about including it in `pom.xml`.

[source, java]
----
@Deployment
public static WebArchive createDeploymentPackage() {
  WebArchive deploymentFile = ShrinkWrap.create(WebArchive.class) //<1>
  .addPackage("com.scytl.hibernate") //<2>
  .addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml") //<3>
  return deploymentFile;
}
----
<1> Creates a `war` file in memory. You could create an `ear` or `jar` file as well.
<2> Adds inside the `war` file all classes under the package `com.scytl.hibernate`. That is inside a virtual directory called `WEB-INF/classes` as `war` spec suggests.
<3> Adds an empty file called `beans.xml` as `WEB-INF` resource. That is in `WEB-INF` directory.

And with this virtual object file _Arquillian_ manages itself to deploy it to container.

By default _Arquillian_ runs tests inside the container.
This is known as *in-container* mode because _Arquillian_ will package the deployment file along with test and sent it to the container for execution.

But there is also another mode called *client*.
In this case _Arquillian_ will simply deploy the deplpoyment file to the server but the test will remain on client side (running from your JVM).
In these cases you are free to test the container from the outside, as any client (for example browser) will see it.
So for testing _JAX-RS_ applications it may be really useful using _client_ mode instead of _in-container_ ones.

The _Arquillian_ lifecycle in _client_ mode looks like:

[ditaa]
.Arquillian container Lifecycle
....
+-------------+                           /-------------\
|   Client    |                           |    TomEE    |
+-------------+                           \-------------/
      :                                          :
      |         +----------------------+         |
      |---------| Start Embedded TomEE |-------->|
      |         +----------------------+         |
      |                                          |
      |         +-----------------+              |
      |-------->| Call @Deployment|              |
      |         +-----------------+              |
      |                 |                        |
      |<----------------+                        |
      |                                          |
      |       +-----------------------+          |
      |-------|    Deploy Archive     |--------->|
      |       +-----------------------+          |
      |                                          |
      |       +-----------------------+          |
      |------>|    URL interaction    |--------->|
      |       +-----------------------+          |
      |                                          |
      |       +-----------------------+          |
      |-------|   UnDeploy Archives   |--------->|
      |       +-----------------------+          |
      |                                          |
      |       +-----------------------+          |
      |------ | Stop Embedded TomEE   |--------->|
      |       +-----------------------+          |
      |                                          |
....

Note that now the deployment file is deployed (but not the test) and instead of running test inside container, test is run inside the client and it communicates with container as any other client would do, by using a _URL_.

Let's see an example on how to use _client_ mode with RESTful Web Services.

[source, java]
.com/scytl/rest/PersonResource.java
----
package com.scytl.rest;


import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/person") //<1>
public class PersonResource {

  private String OUTPUT = "{\n" +
  "  \"firstName\": \"John\",\n" +
  "  \"lastName\": \"Smith\",\n" +
  "  \"isAlive\": true,\n" +
  "  \"age\": 25,\n" +
  "  \"height_cm\": 167.6,\n" +
  "  \"address\": {\n" +
  "    \"streetAddress\": \"21 2nd Street\",\n" +
  "    \"city\": \"New York\",\n" +
  "    \"state\": \"NY\",\n" +
  "    \"postalCode\": \"10021-3100\"\n" +
  "  },\n" +
  "  \"phoneNumbers\": [\n" +
  "    {\n" +
  "      \"type\": \"home\",\n" +
  "      \"number\": \"212 555-1234\"\n" +
  "    },\n" +
  "    {\n" +
  "      \"type\": \"office\",\n" +
  "      \"number\": \"646 555-4567\"\n" +
  "    }\n" +
  "  ],\n" +
  "  \"children\": [],\n" +
  "  \"spouse\": null\n" +
  "}";

  @GET
  @Path("{personId}")
  @Produces(MediaType.APPLICATION_JSON)
  public Response person(@PathParam("personId") String bookId) {
    return Response.ok(OUTPUT).build(); //<2>
  }

}
----
<1> Common _JAX-RS_ annotations are used in the example.
<2> Service returns a _JSON_ document.

So now we need to write a test.
It will use _Arquillian_ to deploy the `PersonResource` inside container and then use `Rest-Assured` for connecting to the service and assert the output message.

.About REST-Assured
****
Testing and validating _REST_ services in Java is harder than in dynamic languages such as _Ruby_ and _Groovy_.
*REST Assured* brings the simplicity of using these languages into the Java domain.

More examples of how to use it can be found at https://code.google.com/p/rest-assured/wiki/Usage.

Only one dependency is required to use _REST-assured_ in a project.

[source, xml]
.pom.xml
----
<dependency>
  <groupId>com.jayway.restassured</groupId>
  <artifactId>rest-assured</artifactId>
  <version>2.4.0</version>
  <scope>test</scope>
</dependency>
----

****

[source, java]
.com/scytl/rest/PersonResourceTest.java
----
package com.scytl.rest;

import static com.jayway.restassured.RestAssured.get;
import static org.junit.Assert.assertThat;
import static org.hamcrest.CoreMatchers.is;


import com.jayway.restassured.path.json.JsonPath;
import org.jboss.arquillian.container.test.api.Deployment;
import org.jboss.arquillian.junit.Arquillian;
import org.jboss.arquillian.test.api.ArquillianResource;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.WebArchive;
import org.junit.Test;
import org.junit.runner.RunWith;

import javax.ws.rs.core.UriBuilder;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;

@RunWith(Arquillian.class) //<1>
public class PersonResourceTest {

  @Deployment(testable = false) //<2>
  public static WebArchive createDeployment() {
    return ShrinkWrap.create(WebArchive.class, "persontest.war")
    .addClass(PersonResource.class);
  }

  @ArquillianResource //<3>
  URL baseUrl;

  @Test
  public void shouldReturnExpectedPerson() {
    URI endpoint = UriBuilder.fromPath(baseUrl.toExternalForm()).path(PersonResource.class).path("1").build(); //<4>
    InputStream response = get(endpoint).then().statusCode(200).extract().asInputStream(); //<5>

    JsonPath jsonPath = new JsonPath(response);
    String firstName = jsonPath.getString("firstName"); //<6>
    String streetAddress = jsonPath.getString("address.streetAddress"); //<7>

    assertThat(firstName, is("John"));
    assertThat(streetAddress, is("21 2nd Street")); //<8>
  }

}
----
<1> Tests should be annotated with `Arquillian` runner.
<2> Sets test to be run in container by using `testeable = false`.
<3> The deployed file is deployed in a server. Using `@ArquillianResource` the URL where the file is deployed is injected on test.
<4> Creates the _URI_ where endpoint is mapped.
<5> Uses `get` static method (provided by REST-assured) to do an invocation using `HTTP GET` to procided direction and asserts that the status code is the expected one.
<6> `JsonPath` class allows you to use _XPath_ like expressions but for _JSON_.
<7> `streetAddress` value is got from returned _JSON_ document.
<8> Standard `assertThat` method from _JUnit_ is used.

== Advanced

=== Matrix Params

=== Sub-resource locator

Resource classes can partially process a request and then provide another sub-resource object to process the remainder of the request.
This approach can be used in different situations, but one situation that fits pretty well is to deal with "`M to 1`" relationships.

Resource methods with a `@Path` annotation and no _HTTP_ method are considered sub-resource locators and they provide an object that can process the request.

Let's see an example.
In previous examples we have worked with _Book_ entity which can be something like:

[source, java]
.Book.java
----
public class Book {

  private long id;
  private String title;

  public Book(long id, String title) {
    this.title = title;
    this.id = id;
  }

  public String getTitle() {return title;}
  public int getId() {return 1;}
}
----

And when `GET /book/12` is executed, the _book_ with _id_ 12 is returned.

But let's add a _Chapter_ entity and how it is related with _Book_.

[source, java]
.Chapter.java
----
public class Chapter {

  private long id;
  private String title;
  private String content;

  private Book book;

  public Chapter(long id, String title, String content, Book book) {
    this.id = id;
    this.title = title;
    this.content = content;
    this.book = book;
  }

  public long getId() { return id; }
  public String getTitle() { return title; }
  public String getContent() { return content; }
  public Book getBook() { return book; }
}
----

One book contains one or more chapters.
So new _book_ entity should be modified to:

[source, java]
.Book.java
----
public class Book {

  private long id;
  private String title;

  private List<Chapter> chapters = new ArrayList<Chapter>();

  public Book(long id, String title) {
    this.title = title;
    this.id = id;
  }

  public void addChapter(Chapter chapter) { this.chapters.add(chapter); }
  public List<Chapter> getChapters() { return chapters; }
  public String getTitle() { return title; }
  public long getId() { return id; }
}
----

To return all _chapters_ of given _book_, you can do something like:

[source, java]
.BookResource.java
----
@Path("/books")
public class BookResource {

  @GET
  @Path("{bookId: [0-9]+}/chapters")
  @Produces(MediaType.APPLICATION_JSON)
  public Response chapters(@PathParam("bookId")Long bookId) {
    Book book = findBookById(bookId);
    return Response.ok(book.getChapters()).build(); //<1>

}
----
<1> List of chapters are returned from `BookResource` class.

We can access this resource in `http://<host>:<port>/<application>/books/123/chapters` and the list of chapters will be returned.

No secret here and no *sub resources* involved yet.
But note that we are mixing _books_ with _chapters_ in same endpoint.
It is better to maintain classes as simple as possible, and more important doing the work they were designed for, in case of `BookResource` it is dealing with books and not chapters.

So one way is make `Book` as *sub resource*.
Thanks of subresources, all RESTful endpoint matching releated with returning a list of chapters will be delegated to `Book` itself.
Because `Book` is responsible of knowing that it contains a list of chapters, it should be the responsible of returning them as well.
Let's see how to do it in _JAX-RS_.

First thing to do is set that `chapters` method from `BookResource` returns a subresource instead of a resource.
This is accomplished by removing _HTTP_ method annotation.

[source, java]
.BookResource.java
----
@Path("/books")
public class BookResource {

  @Path("{bookId: [0-9]+}") //<1> <2>
  public Book chapters(@PathParam("bookId")Long bookId) {

    Book book = findBookById(bookId);
    return book; //<3>
  }
}
----
<1> Only path realated with book is set.
<2> No _HTTP_ method annotation is present.
<3> Finally we return the subresource.

And next step is define that `Book` is a subresource and must contains the path part not set in `BookResource`.

[source, java]
.Book.java
----
public class Book {

  private long id;
  private String title;

  private List<Chapter> chapters = new ArrayList<Chapter>();

  public Book() {
  }

  public Book(long id, String title) {
    this.title = title;
    this.id = id;
  }

  public void addChapter(Chapter chapter) {
    this.chapters.add(chapter);
  }

  @GET //<1>
  @Produces(MediaType.APPLICATION_JSON)
  @Path("/chapters") //<2>
  public List<Chapter> getChapters() {
    return chapters; //<3>
  }
}
----
<1> _HTTP_ method is set so this method returns a full resource.
<2> `@Path` sets the subresource path.
<3> Returns a list of all chapters.

We can access this resource in `http://<host>:<port>/<application>/books/123/chapters` and the list of chapters will be returned.
But now the code will do next steps.
First of all it will run `http://<host>:<port>/<application>/books/123` in `BookResource`.
Because it returns a subresource, the engine will continue inspecting the part not processed of the _URI_, in this case `/chapters`, through returned subresource.
So it will find that `Book` class contains a method annotated with `@Path("/chapters")`, and because it matches, the method will be executed by returning a list of chapters.

TIP: You can use the same approach to return single attribute in case client needs to access them from your _REST_ API, for example `/books/title`.
[TIP]
====
In this example the entity class has been used as subresource.
But if you want to maintain your entity classes anemic, you can create a subresource class such as `BookSubresource` that wraps `Book`.
====

=== Versioning

As seen in <<versioning-rest, REST versioning>>, RESTful Web Services are going to be versioned (in case it is necessary) using _URL_ path to set version number of _API_.

Versioning can be implemented following different approaches, but using <<Application>> may be cleaner way to implement it.

Let's suppose we have different resources and we want to give support to two different versions '`v1`' and '`v2`'.
The first thing to do is create two applications, one for each version.

[source, java]
.V1Application.java
----
@ApplicationPath("/v1") //<1>
public class V1Application {

  @Override
  public Set<Class<?>> getClasses() {
    Set<Class<?>> s = new HashSet<Class<?>>();
    s.add(ChapterResourceV1.class); // <2> <3>
    return s;
    }
}
----
<1> Version 1 is identified as '`v1`' in _URL_.
<2> It registers the _Chapter_ resource that contains the implementation of version 1.
<3> And the same for all resources available in version 1 of the _API_.

[source, java]
.ChapterResourceV1.java
----
public class ChapterResourceV1 {

  @GET
  @Path("/") //<1>
  @Produces(MediaType.APPLICATION_JSON)
  public Chapter chapter() {
    return ...;
  }
}
----

And then a second version of the _API_ is developed.
What we need to do is create a new application for version 2.

[source, java]
.V2Application.java
----
@ApplicationPath("/v2") //<1>
public class V2Application {

  @Override
  public Set<Class<?>> getClasses() {
    Set<Class<?>> s = new HashSet<Class<?>>();
    s.add(ChapterResourceV2.class);
    return s;
    }
}
----
<1> Version 2 is identified as '`v2`' in _URL_.

We can access this resource in `http://<host>:<port>/<application>/v1/chapter` and the list of chapters will be returned using '`v1`' resource.
Accessing `http://<host>:<port>/<application>/v2/chapter` the list of chapters will be returned as wel but using '`v2`' resource instead.

=== PATCH and JAX-RS

Current version of _JAX-RS_ (v2.0) does not implement _PATCH_ _HTTP_ method.
But _JAX-RS_ allows developers to implement their own methods, so in this case we could implement by ourselves the _PATCH_ one.

[source, java]
.PATCH.java
----
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@HttpMethod("PATCH") //<1>
public @interface PATCH {

}
----
<1> To implement an _HTTP_ mehtod, `HttpMethod` must be used.

And `PATH` can be used without any problem as `GET`, `POST`, ...

[source, java]
.BookResource.java
----
@PATCH //<1>
@Consumes("application/json-patch") //<2>
public Response patch(JsonArray jsonObject) { //<3>

  //...

  return Response.noContent().build();
}
----
<1> `PATCH` annotation is used without any problem.
<2> `Content-Type` for Patch operation should be `application/json-patch`.
<3> Patch content is an array of operations to be executed.

We can access this resource in `http://<host>:<port>/<application>/book` with _HTTP_ method _PATCH_ and `Content-Type` as `application/json-patch`.

=== Chunk Upload

In <<Chunked Upload>> we described how implement an upload of a huge chunked bytes in _REST_.

[source, java]
.Initial upload
----
@Inject
TemporaryFolder temporaryFolder;

@POST
@Path("/chunkedUpload")
@Consumes("*/*")
@Produces(MediaType.APPLICATION_JSON)
public Response chunked(InputStream reader) throws IOException {
  UUID uploadId = UUID.randomUUID(); //<1>

  java.nio.file.Path file = temporaryFolder.newFile(uploadId.toString()); //<2>
  long offset = IOUtil.copyToFile(file, reader, Integer.MAX_VALUE); //<3>
  return Response
    .status(202)
    .entity("{\n" + "  \"uploadId\": \"" + uploadId + "\",\n"
      + "  \"offset\": " + offset + "\n" + "}").build();
}
----
<1> Generates a random number as `uploadId`.
<2> Creates a new file using the generated _UUID_ in a temporal directory.
<3> Copies content to temporal file. Lat argument is to limit the amount of bytes that can be saved per chunked.

[source, java]
.Successive calls
----
@PUT
@Path("/chunkedUpload")
@Consumes("*/*")
@Produces(MediaType.APPLICATION_JSON)
public Response chunked(InputStream reader, @QueryParam("uploadId") String uploadId, @QueryParam("offset") Long offset) throws IOException {
  File file = new File(temporaryFolder.getRoot(), uploadId);

  if(isUploadIdValid(file)) {
    if(isOffsetValid(file, offset)) { //<1>
      long newOffset = IOUtil.copyToFile(file.toPath(), reader, Integer.MAX_VALUE); //<2>

      return Response.status(202).entity("{\n" +
        "  \"uploadId\": \""+uploadId+"\",\n" +
        "  \"offset\": " + (offset + newOffset) + "\n" +
        "}").build();

    } else {
      return Response.status(400).build();
    }
  } else {
    return Response.noContent().build();
  }
}

private boolean isOffsetValid(File file, long offset) {
  return file.length() == offset;
}

private boolean isUploadIdValid(File file) {
  return file.exists();
}
----
<1> Checks if `uploadId` exists and if the offset is correct.
<2> Appends content to the already created file.

[source, java]
.Commit
----
@POST
@Path("/commitChunkedUpload")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response commit(@QueryParam("uploadId") String uploadId, String content) {
  File file = new File(temporaryFolder.getRoot(), uploadId);

  if(isUploadIdValid(file)) {
    JsonReader parser = Json.createReader(new StringReader(content));
    JsonObject readObject = parser.readObject(); //<1>
    file.renameTo(new File(temporaryFolder.getRoot(), readObject.getString("filename"))); //<2>

    return Response.created(URI.create("/"+uploadId)).build();
  } else {
    return Response.noContent().build();
  }
}
----
<1> Parses the _JSON_ document-
<2> Gets filename provided and renames the uploaded file. Note that this operation can be insecure and should require security checks depending on project.

=== REST Polling

=== Security

==== Authentication

As mentioned in <<JSON Web Token>> section, _JWT_ is the approach used to secure RESTful Web Service endpoints.
For this example and to simplify things we are going to use the _JAX-RS 2.0_ specification because it implements a concept called *server filters* that really fits our requirements.
Filters can be used when you want to modify any request or response parameters as well as implementing authorization strategies.

First thing is creating a class that represents our user and it must implements `java.security.Principal`.

[[userclass]]
[source, java]
.User.java
----
public class User implements Principal {

  private String username; //<1>

  private List<String> roles = new ArrayList<String>();

  public User(String username, String... roles) {
    super();
    this.username = username;
    this.roles = Arrays.asList(roles);
  }

  @Override
  public String getName() { //<2>
    return username;
  }

  public boolean isUserInRole(String role) { //<3>
    return this.roles.contains(role);
  }
}
----
<1> All required information about user can be set as attributes. In this example only username is required.
<2> `Principal` has only one method to override and it is an string that identifies a user.
<3> Checks if current user belongs to passed role.

Next step is create an _authentication_ filter.
This filter is responsible of getting token from `x-access-token` header attribute, validate the token and get user information to be able to find the roles which belongs, and finally create the *security context* based on _jwt_.

[source, java]
.JWTAuthenticationFilter.java
----
@Provider //<1>
@Priority(Priorities.AUTHENTICATION) //<2>
public class JWTAuthenticationFilter implements ContainerRequestFilter { //<3>

  private static final List<Class<? extends Annotation>> securityAnnotations = Arrays.asList(DenyAll.class, PermitAll.class, RolesAllowed.class);

  @Context
  private ResourceInfo resourceInfo; //<4>

  @Override
  public void filter(ContainerRequestContext request) throws IOException {


      if(isSecuredResource()) { //<5>

        String token = request.getHeaderString("x-access-token"); //<6>

        try {
          String username = getUsernameFromToken(token); //<7>
          final User user = getUserByName(username); //<8>

          request.setSecurityContext(new SecurityContext() { //<9>

            @Override
            public boolean isUserInRole(String role) { return user.isUserInRoles(role);}

            @Override
            public boolean isSecure() { return false;}

            @Override public Principal getUserPrincipal() { return user;}

            @Override
            public String getAuthenticationScheme() { return SecurityContext.BASIC_AUTH;}
            });

        } catch (ParseException | JOSEException e) {
          request.abortWith(Responses.NOT_FOUND);
        }
      }
  }

  private boolean isSecuredResource() {

    for (Class<? extends Annotation> securityClass : securityAnnotations) {
      if(resourceInfo.getResourceMethod().isAnnotationPresent(securityClass)) {
        return true;
      }
    }

  for (Class<? extends Annotation> securityClass : securityAnnotations) {
      if(resourceInfo.getResourceClass().isAnnotationPresent(securityClass)) {
        return true;
      }
    }

    return false;
  }

  private String getUsernameFromToken(String token) throws ParseException, JOSEException {

    SignedJWT signedJWT = SignedJWT.parse(token); //<10>
    JWSVerifier verifier = new MACVerifier(SharedSecret.getSecret());

    if(signedJWT.verify(verifier)) {
      return signedJWT.getJWTClaimsSet().getSubject(); //<11>
    } else {
      throw new JOSEException("Firm is not verified.");
    }
  }
}
----
<1> To plug a filter you must annotate it with `@Provider`.
<2> Filter is executed during *authentication* phase.
<3> Because filter is executed in server-side, it must implements `ContainerRequestFilter`.
<4> `ResourceInfo` is injected to get information about endpoint method that is going to be called.
<5> Checks if method is secured or not by verifying the presence of Java EE Security annotation.
<6> As described in <<JSON Web Token>> section, _token_ must be set in `x-access-token` header attribute.
<7> Gets username value from _token_.
<8> With given username, the information about the <<userclass, user>> is returned from repository. Basically roles where user has access are returned.
<9> A custom `SecurityContext` class to verify if user has the expected roles.
<10> Parse the passed _token_.
<11> If _token_ is valid and is verified as a _token_ generated by the system, we can get the _subject_ field. _Subject_ claim field is used to save username.

.Nimbus JOSE + JWT
****
In this example we are using Nimbus JOSE + JWT library to create, parse, verify, ... _JWT_ tokens.

Nimbus JOSE + JWT is an open source Java library which implements the Javascript Object Signing and Encryption (_JOSE_) spec suite and the closely related JSON Web Token (_JWT_) spec.

A full description can be read at http://connect2id.com/products/nimbus-jose-jwt
****

And finally an _authorization_ filter.
This filter is responsible of ensuring that the user has the required rights to access to resource.

[source, java]
.RolesAllowedFilter.java
----
@Provider
@Priority(Priorities.AUTHORIZATION) //<1>
public class RolesAllowedFilter implements ContainerRequestFilter {

  private static final Response NOT_FOUND = Response.status(
      Response.Status.NOT_FOUND).entity("{\"message\": \"Resource Not Found\"}").build();

  @Context
  private ResourceInfo resourceInfo;

  @Override
  public void filter(ContainerRequestContext requestContext)
      throws IOException {
    Method resourceMethod = resourceInfo.getResourceMethod();

    // DenyAll on the method take precedence over RolesAllowed and PermitAll
    if (resourceMethod.isAnnotationPresent(DenyAll.class)) {
      requestContext.abortWith(NOT_FOUND);
      return;
    }

    // RolesAllowed on the method takes precedence over PermitAll
    RolesAllowed ra = resourceMethod.getAnnotation(RolesAllowed.class);
    if(assertRole(requestContext, ra)) { //<2>
      return;
    }

    // PermitAll takes precedence over RolesAllowed on the class
    if (resourceMethod.isAnnotationPresent(PermitAll.class)) {
      // Do nothing.
      return;
    }

    if (resourceInfo.getResourceClass().isAnnotationPresent(DenyAll.class)) {
      requestContext.abortWith(NOT_FOUND);
    }

    // RolesAllowed on the class takes precedence over PermitAll
    ra = resourceInfo.getResourceClass().getAnnotation(RolesAllowed.class);
    if(assertRole(requestContext, ra)) {
      return;
    }
  }

  private boolean assertRole(ContainerRequestContext requestContext, RolesAllowed ra) {

    if (ra != null) {
      String[] roles = ra.value();
      for (String role : roles) {
        if (requestContext.getSecurityContext().isUserInRole(role)) { //<3>
          return true;
        }
      }
      requestContext.abortWith(NOT_FOUND);
    }
    return false;
  }
}
----
<1> Filter is executed during *authentication* phase.
<2> Asserts if current user is in role list.
<3> Uses `SecurityContext` provided in authentication phase, to check if current user is in endpoint role.

Having both classes in _classpath_, we can use _Java EE_ security annotations to secure RESTful web services.

Let's see how to implement a _login_ service.
Note that this service is not securized.

[source, java]
.UserResource.java
----
@Path("login")
public class UserResource {

  @POST
  @Consumes(MediaType.APPLICATION_JSON)
  @Produces(MediaType.APPLICATION_JSON)
  public Response login(JsonObject jsonObject) throws JOSEException {

    JsonString username = (JsonString) jsonObject.get("username"); //<1>
    JsonString password = (JsonString) jsonObject.get("password");

    if (authenticate(username.getString(), password.getString())) { //<2>

      String token = createToken(username.getString(), "example.com"); //<3>

      JsonObject responseDocument = Json.createObjectBuilder()
        .add("user", Json.createObjectBuilder().add("username", username).build())
        .add("token", token)
        .build(); //<4>

      return Response.ok(responseDocument).build();

    }

    return Response.status(Status.NOT_FOUND).build();

  }

  private String createToken(String subject, String issuer) throws JOSEException {

    JWSSigner signer = new MACSigner(SharedSecret.getSecret());

    JWTClaimsSet claimsSet = new JWTClaimsSet();
    claimsSet.setSubject(subject); //<5>
    claimsSet.setIssueTime(new Date());
    claimsSet.setIssuer(issuer);

    SignedJWT signedJWT = new SignedJWT(new JWSHeader(JWSAlgorithm.HS256), claimsSet);
    signedJWT.sign(signer);

    return signedJWT.serialize(); //<6>

  }
}
----
<1> _username_ and _password_ are sent as document body.
<2> Authenticates given user and password.
<3> Creates the _token_ by using _example.com_ domain as issuer.
<4> Creates the response body document.
<5> Sets username as _subject_ of the _token_.
<6> Returns the _token_ as string.

And a secured resource:

[source, java]
.BookResource.java
----
import javax.annotation.security.RolesAllowed;

@Path("/book")
public class BookResource {

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @RolesAllowed("admin") //<1>
  public String book() {
    //...
  }

  @GET
  @Path("/article")
  @Produces(MediaType.APPLICATION_JSON)
  @RolesAllowed("superadmin")
  public String article() {
    //...
  }

}
----
<1> Only users with role _admin_ can access to this resource.
